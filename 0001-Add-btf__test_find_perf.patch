diff --git a/tools/testing/selftests/bpf/prog_tests/btf_permute.c b/tools/testing/selftests/bpf/prog_tests/btf_permute.c
index f67bf89519b3..3acc1ce63e04 100644
--- a/tools/testing/selftests/bpf/prog_tests/btf_permute.c
+++ b/tools/testing/selftests/bpf/prog_tests/btf_permute.c
@@ -1,10 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0
 /* Copyright (c) 2025 Xiaomi */
 
+#include <sys/time.h>
+#include <sys/stat.h>
 #include <test_progs.h>
 #include <bpf/btf.h>
 #include "btf_helpers.h"
 
+struct btf_test_meta {
+	const char *name;
+	__u32 kind;
+	__u32 id;
+};
+
 /* Ensure btf__permute work as expected with base BTF */
 static void test_permute_base(void)
 {
@@ -593,6 +601,90 @@ static void test_permute_drop_dedup(void)
 	btf__free(new_btf);
 }
 
+static void test_permute_perf_fn(void)
+{
+	const char *sysfs_btf_path = "/sys/kernel/btf/vmlinux";
+	struct stat st;
+	struct btf *btf;
+	const struct btf_type *t;
+	struct btf_test_meta *tm = NULL;
+	struct timeval start, end;
+	long total, elapsed[10];
+	__u32 n, start_id = 1;
+	__u8 *str_ref = NULL;
+	int i, j, ret, count;
+	bool test_fail = false;
+
+	btf = btf__load_vmlinux_btf();
+	if (!ASSERT_OK_PTR(btf, "load_vmlinux_btf"))
+		return;
+	n = btf__type_cnt(btf);
+	ret = stat(sysfs_btf_path, &st);
+	if (!ASSERT_OK(ret, "stat"))
+		return;
+	str_ref = calloc(st.st_size, sizeof(str_ref));
+	if (!ASSERT_OK_PTR(str_ref, "calloc_str_ref"))
+		return;
+	tm = calloc(n, sizeof(*tm));
+	if (!ASSERT_OK_PTR(tm, "calloc_tm"))
+		return;
+
+	for (i = start_id; i < n; i++) {
+		t = btf__type_by_id(btf, i);
+		if (str_ref[t->name_off] < 2)
+			str_ref[t->name_off]++;
+	}
+
+	/* Only consider types without share name with others */
+	for (j = 0, i = start_id; i < n; i++) {
+		t = btf__type_by_id(btf, i);
+		if (str_ref[t->name_off] != 1)
+			continue;
+		tm[j].id = i;
+		tm[j].name = btf__str_by_offset(btf, t->name_off);;
+		tm[j].kind = btf_kind(t);
+		j++;
+	}
+
+	count = ARRAY_SIZE(elapsed);
+	total = 0;
+	printf("Test to find %d types %d times:\n", j, count);
+
+	/* ignore sort check overhead */
+	btf__find_by_name_kind(btf, tm[0].name, tm[0].kind);
+
+repeat:
+	gettimeofday(&start, NULL);
+	for (i = 0; i < j; i++) {
+		ret = btf__find_by_name_kind(btf, tm[i].name, tm[i].kind);
+		if (ret != tm[i].id) {
+			fprintf(stderr, "test fail: actual %d, expect: %d for %s\n",
+				ret, tm[i].id, tm[i].name);
+			test_fail = true;
+		}
+	}
+	gettimeofday(&end, NULL);
+
+	elapsed[count-1] = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
+	printf("Consume: %ld us\n", elapsed[count - 1]);
+	total += elapsed[count - 1];
+
+	if (--count > 0)
+		goto repeat;
+
+	printf("average: %ld us\n", total/ARRAY_SIZE(elapsed));
+
+	btf__free(btf);
+	free(str_ref);
+	free(tm);
+	ASSERT_OK(test_fail, "find_perf");
+}
+
+static void test_permute_perf(void)
+{
+	test_permute_perf_fn();
+}
+
 void test_btf_permute(void)
 {
 	if (test__start_subtest("permute_base"))
@@ -605,4 +697,6 @@ void test_btf_permute(void)
 		test_permute_drop_split();
 	if (test__start_subtest("permute_drop_dedup"))
 		test_permute_drop_dedup();
+	if (test__start_subtest("perf"))
+		test_permute_perf();
 }
